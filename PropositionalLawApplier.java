package edu.unl.raikes.discrete.logicproofs;

import edu.unl.raikes.discrete.propositions.NotProposition;
import edu.unl.raikes.discrete.propositions.Proposition;
import edu.unl.raikes.discrete.propositions.SentenceProposition;
import edu.unl.raikes.discrete.propositions.VariableProposition;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * The PropositionalLawApplier type is used to apply laws of logic to propositions, in order to create new propositions.
 */
public class PropositionalLawApplier {

    /**
     * This function applies a given law to a given truth. If the law requires additional truths, such truths will be
     * found (assuming they exist). If the law cannot be applied to the given truth, or if the additional truths do not
     * exist in allTruths, the function returns null. If the law can be applied, the function returns the new truth
     * generated by the law.
     *
     * @param law the law to be applied
     * @param truth the truth to which you'd like to apply the law
     * @param allTruths all of the truths known at this time
     * @return the new truths generated from the provided law and truth
     */
    public static List<PropositionalEquation> applyTo(PropositionalLaw law, PropositionalEquation truth,
            List<PropositionalEquation> allTruths) {
        // this maps template variables (e.g. a, b, c) with the real values from the truth (e.g. P>Q, -R)
        Map<Proposition, Proposition> mapping = null;
        // this is a template from the provided law that matches the provided truth
        Proposition matchedTemplate = null;

        // test if this truth matches any templates included in required components
        for (Proposition reqComponent : law.getRequiredComponents()) {
            if (truthMatchesTemplate(truth.getProposition(), reqComponent)) {
                matchedTemplate = reqComponent;
                mapping = getAbstractToTruthVariableMapping(truth.getProposition(), reqComponent);
                break;
            }
        }

        // if not, return null
        if (mapping == null) {
            return null;
        }

        List<PropositionalEquation> newTruths = new ArrayList<PropositionalEquation>();

        // is this the only component required by this law that needs to be found?
        // if so, skip some steps
        if (law.getRequiredComponents().size() == 1) {
            // get the new truth promised by the law
            Proposition newTruthProp = makeNewTruth(mapping, law.getNewTruthTemplate());
            // only one template means only one parent
            List<PropositionalEquation> parents = new ArrayList<PropositionalEquation>();
            parents.add(truth);
            // create the propositional equation and add it to collection
            PropositionalEquation newTruth = new PropositionalEquation(newTruthProp, law, parents);
            newTruths.add(newTruth);

        } else {
            // if there's more than one component required (there are no more than 2), find the second
            Proposition secondTemplate = law.getRequiredComponents().get(0);
            if (matchedTemplate == law.getRequiredComponents().get(0)) {
                secondTemplate = law.getRequiredComponents().get(1);
            }

            // loop through all truths (the second template may match more than one truth)
            for (PropositionalEquation otherTruth : allTruths) {
                // copy the map so we don't damage it
                Map<Proposition, Proposition> mappingCopy = new TreeMap<Proposition, Proposition>();
                mappingCopy.putAll(mapping);
                // if this truth isn't the one that was sent into the function (it's matched to templateMatch)
                if (otherTruth != truth
                        && truthMatchesTemplateWithMap(mappingCopy, otherTruth.getProposition(), secondTemplate)) {
                    // generate the truth promised by the law using the values in the map
                    Proposition newTruthProp = makeNewTruth(mappingCopy, law.getNewTruthTemplate());

                    // does the list already have this truth?
                    if (getPropositionFromList(allTruths, newTruthProp) == null) {
                        // two matches means two parents
                        List<PropositionalEquation> parents = new ArrayList<PropositionalEquation>();
                        parents.add(truth);
                        parents.add(otherTruth);
                        // create the propositional equation and add it to the collection
                        PropositionalEquation newTruth = new PropositionalEquation(newTruthProp, law, parents);
                        newTruths.add(newTruth);
                    }
                }
            }
        }

        // we learned something new!
        if (newTruths.size() > 0) {
            return newTruths;
        }
        // learned nothing new
        return null;
    }

    /**
     * This function determines whether the provided list contains an equation that contains the provided proposition.
     * 
     * @param list the list within which the user wants to find the equation containing the provided proposition.
     * @param proposition the proposition belonging to the equation the user wants to find
     * @return the equation from the list that has the provided proposition, null if not found
     */
    public static PropositionalEquation getPropositionFromList(List<PropositionalEquation> list,
            Proposition proposition) {
        for (PropositionalEquation truth : list) {
            if (truth.getProposition().equals(proposition)) {
                return truth;
            }
        }

        return null;
    }

    /**
     * This determines whether a given proposition meets the structural requirements of a template.
     *
     * @param truth the "real" proposition you're testing
     * @param template the proposition that describes the desired structure
     * @return true if the truth matches the structural requirements of the template, false otherwise.
     */
    static boolean truthMatchesTemplate(Proposition truth, Proposition template) {
        return truthMatchesTemplateWithMap(new TreeMap<Proposition, Proposition>(), truth, template);
    }

    /**
     * This function takes a mapping of template to real propositions and generates a new truth using the provided new
     * truth template.
     *
     * @param mapping the mapping of template variables to real propositions
     * @param template the template outlining the structure of the new truth
     * @return a new truth in the template's structure, but with the variables replaced with the mapping's values
     */
    static Proposition makeNewTruth(Map<Proposition, Proposition> mapping, Proposition template) {
        // make a copy of the template
        Proposition templateCopy = template.copy();
        // loop through each key in the mapping
        templateCopy = templateCopy.replace(mapping);

        // tell the template to find and replace
        return templateCopy;
    }

    /**
     * This determines whether a given proposition meets the structural requirements of a template, given that some
     * variables in the template may already have been mapped.
     *
     * @param map a mapping of the template variables to their "real" counterpart propositions
     * @param truth the "real" proposition you're testing
     * @param template the proposition that describes the desired structure
     * @return true if the truth matches the structural requirements of the template & map, false otherwise.
     */
    static boolean truthMatchesTemplateWithMap(Map<Proposition, Proposition> map, Proposition truth,
            Proposition template) {
        final List<Proposition> DUMMY_VARS = PropositionalLaw.getTemplateVariables();

        // if the template is included in our list of abstract variables, we're done. this is the base case
        if (DUMMY_VARS.contains(template)) {
            if (map.containsKey(template) && map.get(template).equals(truth)) {
                return true;
            } else if (map.containsKey(template)) {
                return false;
            } else {
                map.put(template, truth);
                return true;
            }
        }
        // other base case is if the template and truth equation are not the same type, reject right away
        if (template.getClass() != truth.getClass()) {
            return false;
        }
        // this covers nots
        if (template instanceof NotProposition) {
            NotProposition notTemplate = (NotProposition) template;
            NotProposition notTruth = (NotProposition) truth;

            // recurse on notted var
            return truthMatchesTemplateWithMap(map, notTruth.getProposition(), notTemplate.getProposition());
        } else {
            // must be a sentence proposition
            SentenceProposition sentenceTemplate = (SentenceProposition) template;
            SentenceProposition sentenceTruth = (SentenceProposition) truth;
            // recurse left of template, get map
            boolean leftMatch = truthMatchesTemplateWithMap(map, sentenceTruth.getLeft(), sentenceTemplate.getLeft());
            // recurse right of template, get map
            boolean rightMatch = truthMatchesTemplateWithMap(map, sentenceTruth.getRight(),
                    sentenceTemplate.getRight());
            return leftMatch && rightMatch;
        }
    }

    /**
     * This function finds the propositions that the variables in a template represent. That is, if a template has some
     * blanks that need to be filled in, this function figures out what goes in those blanks. Precondition: This
     * function assumes that truthMatchesTemplate returns true.
     *
     * @param truth the real proposition
     * @param template the proposition that describes the desired structure
     * @return a map of template variable to actual proposition mappings
     */
    static Map<Proposition, Proposition> getAbstractToTruthVariableMapping(Proposition truth, Proposition template) {

        Map<Proposition, Proposition> map = new TreeMap<Proposition, Proposition>();

        return updateAbstractToTruthVariableMapping(map, truth, template);

    }

    /**
     * This function finds and/or updates the a mapping of template variables to real propositions. That is, if a
     * template has some blanks that need to be filled in, this function figures out what goes in those blanks.
     * Precondition: This function assumes that truthMatchesTemplate returns true.
     * 
     * @param map a mapping of template variables to real propositions
     * @param truth the real proposition
     * @param template the template of the proposition that describes the desired structure
     * @return a map of template variables to actual propositions, updated with the values of in provided truth
     */
    static Map<Proposition, Proposition> updateAbstractToTruthVariableMapping(Map<Proposition, Proposition> map,
            Proposition truth, Proposition template) {
        final List<Proposition> DUMMY_VARS = PropositionalLaw.getTemplateVariables();

        if (map.containsValue(truth)) {
            return map;
        }
        // this covers single variable propositions
        if (DUMMY_VARS.contains(template) && !map.containsKey(template)) {
            map.put(template, truth);
            return map;
        }
        // this covers nots
        // using reflection this way is a code smell. consider refactoring at a later time
        if (template instanceof NotProposition) {
            NotProposition notTemplate = (NotProposition) template;
            NotProposition notTruth = (NotProposition) truth;

            // recurse on notted var
            return getAbstractToTruthVariableMapping(notTruth.getProposition(), notTemplate.getProposition());
        } else {
            // must be a sentence proposition
            SentenceProposition sentenceTemplate = (SentenceProposition) template;
            SentenceProposition sentenceTruth = (SentenceProposition) truth;
            // recurse left of template, get map
            Map<Proposition, Proposition> leftMap = getAbstractToTruthVariableMapping(sentenceTruth.getLeft(),
                    sentenceTemplate.getLeft());
            // recurse right of template, get map
            Map<Proposition, Proposition> rightMap = getAbstractToTruthVariableMapping(sentenceTruth.getRight(),
                    sentenceTemplate.getRight());
            // combine maps
            map.putAll(rightMap);
            map.putAll(leftMap);
            return map;
        }
    }

}
